<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FxCommon</name>
    </assembly>
    <members>
        <!-- 对于成员“M:ServiceStack.AssertUtils.AreNotNull(System.Collections.Generic.IDictionary{System.String,System.Object})”忽略有格式错误的 XML 注释 -->
        <member name="M:ServiceStack.CommandsUtils.ExecuteAsyncCommandExec(System.Collections.Generic.IEnumerable{ServiceStack.Commands.ICommandExec})">
            <summary>
            Provide the an option for the callee to block until all commands are executed
            </summary>
            <param name="commands"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.EnumerableExtensions.Safe``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Return T[0] when enumerable is null, safe to use in enumerations like foreach
            </summary>
        </member>
        <member name="M:ServiceStack.EnumExtensions.ToDescription(System.Enum)">
            <summary>
            Gets the textual description of the enum if it has one. e.g.
            
            <code>
            enum UserColors
            {
                [Description("Bright Red")]
                BrightRed
            }
            UserColors.BrightRed.ToDescription();
            </code>
            </summary>
            <param name="enum"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.FuncUtils.TryExec(System.Action)">
            <summary>
            Invokes the action provided and returns true if no excpetion was thrown.
            Otherwise logs the exception and returns false if an exception was thrown.
            </summary>
            <param name="action">The action.</param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.IPAddressExtensions">
            <summary>
            Useful IPAddressExtensions from: 
            http://blogs.msdn.com/knom/archive/2008/12/31/ip-address-calculations-with-c-subnetmasks-networks.aspx
            
            </summary>
        </member>
        <member name="M:ServiceStack.IPAddressExtensions.GetAllNetworkInterfaceIpv4Addresses">
            <summary>
            Gets the ipv4 addresses from all Network Interfaces that have Subnet masks.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.IPAddressExtensions.GetAllNetworkInterfaceIpv6Addresses">
            <summary>
            Gets the ipv6 addresses from all Network Interfaces.
            </summary>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Logging.ConsoleLogFactory">
            <summary>
            Creates a Console Logger, that logs all messages to: System.Console
            
            Made public so its testable
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.ILogFactory">
            <summary>
            Factory to create ILog instances
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ILogFactory.GetLogger(System.Type)">
            <summary>
            Gets the logger.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ILogFactory.GetLogger(System.String)">
            <summary>
            Gets the logger.
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.ConsoleLogger">
            <summary>
            Default logger is to Console.WriteLine
            
            Made public so its testable
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.ILog">
            <summary>
            Logs a message in a running application
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Debug(System.Object)">
            <summary>
            Logs a Debug message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Debug(System.Object,System.Exception)">
            <summary>
            Logs a Debug message and exception.
            </summary>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.DebugFormat(System.String,System.Object[])">
            <summary>
            Logs a Debug format message.
            </summary>
            <param name="format">The format.</param>
            <param name="args">The args.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Error(System.Object)">
            <summary>
            Logs a Error message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Error(System.Object,System.Exception)">
            <summary>
            Logs a Error message and exception.
            </summary>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.ErrorFormat(System.String,System.Object[])">
            <summary>
            Logs a Error format message.
            </summary>
            <param name="format">The format.</param>
            <param name="args">The args.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Fatal(System.Object)">
            <summary>
            Logs a Fatal message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Fatal(System.Object,System.Exception)">
            <summary>
            Logs a Fatal message and exception.
            </summary>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.FatalFormat(System.String,System.Object[])">
            <summary>
            Logs a Error format message.
            </summary>
            <param name="format">The format.</param>
            <param name="args">The args.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Info(System.Object)">
            <summary>
            Logs an Info message and exception.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Info(System.Object,System.Exception)">
            <summary>
            Logs an Info message and exception.
            </summary>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.InfoFormat(System.String,System.Object[])">
            <summary>
            Logs an Info format message.
            </summary>
            <param name="format">The format.</param>
            <param name="args">The args.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Warn(System.Object)">
            <summary>
            Logs a Warning message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.Warn(System.Object,System.Exception)">
            <summary>
            Logs a Warning message and exception.
            </summary>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:ServiceStack.Logging.ILog.WarnFormat(System.String,System.Object[])">
            <summary>
            Logs a Warning format message.
            </summary>
            <param name="format">The format.</param>
            <param name="args">The args.</param>
        </member>
        <member name="P:ServiceStack.Logging.ILog.IsDebugEnabled">
            <summary>
            Gets or sets a value indicating whether this instance is debug enabled.
            </summary>
            <value>
            	<c>true</c> if this instance is debug enabled; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:ServiceStack.Logging.ConsoleLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ConsoleLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ConsoleLogger.Log(System.Object,System.Exception)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ConsoleLogger.LogFormat(System.Object,System.Object[])">
            <summary>
            Logs the format.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.ConsoleLogger.Log(System.Object)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.DebugLogFactory">
            <summary>
            Creates a Debug Logger, that logs all messages to: System.Diagnostics.Debug
            
            Made public so its testable
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.DebugLogger">
            <summary>
            Default logger is to System.Diagnostics.Debug.WriteLine
            
            Made public so its testable
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.DebugLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.DebugLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.DebugLogger.Log(System.Object,System.Exception)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.DebugLogger.LogFormat(System.Object,System.Object[])">
            <summary>
            Logs the format.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.DebugLogger.Log(System.Object)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="T:ServiceStack.MiniProfiler.Data.ExecuteType">
            <summary>
            Categories of sql statements.
            </summary>
        </member>
        <member name="F:ServiceStack.MiniProfiler.Data.ExecuteType.None">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:ServiceStack.MiniProfiler.Data.ExecuteType.NonQuery">
            <summary>
            DML statements that alter database state, e.g. INSERT, UPDATE
            </summary>
        </member>
        <member name="F:ServiceStack.MiniProfiler.Data.ExecuteType.Scalar">
            <summary>
            Statements that return a single record
            </summary>
        </member>
        <member name="F:ServiceStack.MiniProfiler.Data.ExecuteType.Reader">
            <summary>
            Statements that iterate over a result set
            </summary>
        </member>
        <member name="T:ServiceStack.MiniProfiler.Data.IDbProfiler">
            <summary>
            A callback for ProfiledDbConnection and family
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.IDbProfiler.ExecuteStart(System.Data.Common.DbCommand,ServiceStack.MiniProfiler.Data.ExecuteType)">
            <summary>
            Called when a command starts executing
            </summary>
            <param name="profiledDbCommand"></param>
            <param name="executeType"></param>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.IDbProfiler.ExecuteFinish(System.Data.Common.DbCommand,ServiceStack.MiniProfiler.Data.ExecuteType,System.Data.Common.DbDataReader)">
            <summary>
            Called when a reader finishes executing
            </summary>
            <param name="profiledDbCommand"></param>
            <param name="executeType"></param>
            <param name="reader"></param>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.IDbProfiler.ReaderFinish(System.Data.Common.DbDataReader)">
            <summary>
            Called when a reader is done iterating through the data 
            </summary>
            <param name="reader"></param>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.IDbProfiler.OnError(System.Data.Common.DbCommand,ServiceStack.MiniProfiler.Data.ExecuteType,System.Exception)">
            <summary>
            Called when an error happens during execution of a command 
            </summary>
            <param name="profiledDbCommand"></param>
            <param name="executeType"></param>
            <param name="exception"></param>
        </member>
        <member name="P:ServiceStack.MiniProfiler.Data.IDbProfiler.IsActive">
            <summary>
            True if the profiler instance is active
            </summary>
        </member>
        <member name="T:ServiceStack.MiniProfiler.Data.ProfiledConnection">
            <summary>
            Wraps a database connection, allowing sql execution timings to be collected when a <see cref="T:ServiceStack.MiniProfiler.Data.IDbProfiler"/> session is started.
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledConnection.#ctor(System.Data.Common.DbConnection,ServiceStack.MiniProfiler.Data.IDbProfiler,System.Boolean)">
            <summary>
            Returns a new <see cref="T:ServiceStack.MiniProfiler.Data.ProfiledConnection"/> that wraps <paramref name="connection"/>, 
            providing query execution profiling.  If profiler is null, no profiling will occur.
            </summary>
            <param name="connection">Your provider-specific flavor of connection, e.g. SqlConnection, OracleConnection</param>
            <param name="profiler">The currently started <see cref="T:ServiceStack.MiniProfiler.Data.IDbProfiler"/> or null.</param>
            <param name="autoDisposeConnection">Determines whether the ProfiledDbConnection will dispose the underlying connection.</param>
        </member>
        <member name="P:ServiceStack.MiniProfiler.Data.ProfiledConnection.InnerConnection">
            <summary>
            The underlying, real database connection to your db provider.
            </summary>
        </member>
        <member name="P:ServiceStack.MiniProfiler.Data.ProfiledConnection.Profiler">
            <summary>
            The current profiler instance; could be null.
            </summary>
        </member>
        <member name="P:ServiceStack.MiniProfiler.Data.ProfiledConnection.WrappedConnection">
            <summary>
            The raw connection this is wrapping
            </summary>
        </member>
        <member name="T:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory">
            <summary>
            Wrapper for a db provider factory to enable profiling
            </summary>
        </member>
        <member name="F:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.Instance">
            <summary>
            Every provider factory must have an Instance public field
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.InitProfiledDbProviderFactory(ServiceStack.MiniProfiler.Data.IDbProfiler,System.Data.Common.DbProviderFactory)">
            <summary>
            Allow to re-init the provider factory.
            </summary>
            <param name="profiler"></param>
            <param name="wrappedFactory"></param>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.#ctor(ServiceStack.MiniProfiler.Data.IDbProfiler,System.Data.Common.DbProviderFactory)">
            <summary>
            proxy
            </summary>
            <param name="profiler"></param>
            <param name="wrappedFactory"></param>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateDataSourceEnumerator">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateCommand">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateConnection">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateParameter">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateConnectionStringBuilder">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateCommandBuilder">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreateDataAdapter">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CreatePermission(System.Security.Permissions.PermissionState)">
            <summary>
            proxy
            </summary>
        </member>
        <member name="P:ServiceStack.MiniProfiler.Data.ProfiledProviderFactory.CanCreateDataSourceEnumerator">
            <summary>
            proxy
            </summary>
        </member>
        <member name="M:ServiceStack.PerfUtils.MeasureFor(System.Action,System.Int32)">
            <summary>
            Runs an action for a minimum of runForMs
            </summary>
            <param name="fn">What to run</param>
            <param name="runForMs">Minimum ms to run for</param>
            <returns>time elapsed in micro seconds</returns>
        </member>
        <member name="M:ServiceStack.PerfUtils.Measure(System.Action,System.Int32,System.Int32,System.Action,System.Action,System.Action)">
            <summary>
            Returns average microseconds an action takes when run for the specified runForMs
            </summary>
            <param name="fn">What to run</param>
            <param name="times">How many times to run for each iteration</param>
            <param name="runForMs">Minimum ms to run for</param>
            <param name="setup"></param>
            <param name="warmup"></param>
            <param name="teardown"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Reflection.PropertyAccessor`1.TypedGetPropertyFn``1">
            <summary>
            Func to get the Strongly-typed field
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.PropertyAccessor`1.ValueTypedGetPropertyFn``1">
            <summary>
            Required to cast the return ValueType to an object for caching
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.PropertyAccessor`1.TypedSetPropertyFn``1">
            <summary>
            Func to set the Strongly-typed field
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.PropertyAccessor`1.ValueTypesSetPropertyFn``1">
            <summary>
            Required to cast the ValueType to an object for caching
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.PropertyAccessor`1.UnTypedSetPropertyFn``1">
            <summary>
            Required to cast the ValueType to an object for caching
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.StaticAccessors`1.TypedGetPropertyFn``1(System.Reflection.PropertyInfo)">
            <summary>
            Func to get the Strongly-typed field
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.StaticAccessors`1.ValueUnTypedGetPropertyFn``1(System.Reflection.PropertyInfo)">
            <summary>
            Required to cast the return ValueType to an object for caching
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.StaticAccessors`1.TypedSetPropertyFn``1(System.Reflection.PropertyInfo)">
            <summary>
            Func to set the Strongly-typed field
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.StaticAccessors`1.ValueUnTypedSetPropertyFn``1(System.Reflection.PropertyInfo)">
            <summary>
            Required to cast the ValueType to an object for caching
            </summary>
        </member>
        <member name="M:ServiceStack.Reflection.StaticAccessors`1.UnTypedSetPropertyFn``1(System.Reflection.PropertyInfo)">
            <summary>
            Required to cast the ValueType to an object for caching
            </summary>
        </member>
        <member name="T:ServiceStack.Support.AdapterBase">
            <summary>
            Common functionality when creating adapters
            </summary>
        </member>
        <member name="M:ServiceStack.Support.AdapterBase.Execute``1(System.Func{``0})">
            <summary>
            Executes the specified expression. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action">The action.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Support.AdapterBase.Execute(System.Action)">
            <summary>
            Executes the specified action (for void methods).
            </summary>
            <param name="action">The action.</param>
        </member>
        <member name="T:ServiceStack.Support.InMemoryLogFactory">
            <summary>
            Note: InMemoryLog keeps all logs in memory, so don't use it long running exceptions
            
            Returns a thread-safe InMemoryLog which you can use while *TESTING*
            to provide a detailed analysis of your logs.
            </summary>
        </member>
        <member name="T:ServiceStack.UrnId">
            <summary>
            Creates a Unified Resource Name (URN) with the following formats:
            
            	- urn:{TypeName}:{IdFieldValue}						e.g. urn:UserSession:1
            	- urn:{TypeName}:{IdFieldName}:{IdFieldValue}		e.g. urn:UserSession:UserId:1			
            
            </summary>
        </member>
        <member name="P:ServiceStack.ApiAllowableValuesAttribute.Name">
            <summary>
            Gets or sets parameter name with which allowable values will be associated.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiAttribute.Description">
            <summary>
            The overall description of an API. Used by Swagger.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.Verb">
            <summary>
            Gets or sets verb to which applies attribute. By default applies to all verbs.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.ParameterType">
            <summary>
            Gets or sets parameter type: It can be only one of the following: path, query, body, form, or header.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.Name">
            <summary>
            Gets or sets unique name for the parameter. Each name must be unique, even if they are associated with different paramType values. 
            </summary>
            <remarks>
            <para>
            Other notes on the name field:
            If paramType is body, the name is used only for UI and codegeneration.
            If paramType is path, the name field must correspond to the associated path segment from the path field in the api object.
            If paramType is query, the name field corresponds to the query param name.
            </para>
            </remarks>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.Description">
            <summary>
            Gets or sets the human-readable description for the parameter.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.DataType">
            <summary>
            For path, query, and header paramTypes, this field must be a primitive. For body, this can be a complex or container datatype.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.IsRequired">
            <summary>
            For path, this is always true. Otherwise, this field tells the client whether or not the field must be supplied.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.AllowMultiple">
            <summary>
            For query params, this specifies that a comma-separated list of values can be passed to the API. For path and body types, this field cannot be true.
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.Route">
            <summary>
            Gets or sets route to which applies attribute, matches using StartsWith. By default applies to all routes. 
            </summary>
        </member>
        <member name="P:ServiceStack.ApiMemberAttribute.ExcludeInSchema">
            <summary>
            Whether to exclude this property from being included in the ModelSchema
            </summary>
        </member>
        <member name="P:ServiceStack.IApiResponseDescription.StatusCode">
            <summary>
            The status code of a response
            </summary>
        </member>
        <member name="P:ServiceStack.IApiResponseDescription.Description">
            <summary>
            The description of a response status code
            </summary>
        </member>
        <member name="T:ServiceStack.Caching.ICacheClient">
            <summary>
            A common interface implementation that is implemented by most cache providers
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Remove(System.String)">
            <summary>
            Removes the specified item from the cache.
            </summary>
            <param name="key">The identifier for the item to delete.</param>
            <returns>
            true if the item was successfully removed from the cache; false otherwise.
            </returns>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.RemoveAll(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Removes the cache for all the keys provided.
            </summary>
            <param name="keys">The keys.</param>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Get``1(System.String)">
            <summary>
            Retrieves the specified item from the cache.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key">The identifier for the item to retrieve.</param>
            <returns>
            The retrieved item, or <value>null</value> if the key was not found.
            </returns>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Increment(System.String,System.UInt32)">
            <summary>
            Increments the value of the specified key by the given amount. 
            The operation is atomic and happens on the server.
            A non existent value at key starts at 0
            </summary>
            <param name="key">The identifier for the item to increment.</param>
            <param name="amount">The amount by which the client wants to increase the item.</param>
            <returns>
            The new value of the item or -1 if not found.
            </returns>
            <remarks>The item must be inserted into the cache before it can be changed. The item must be inserted as a <see cref="T:System.String"/>. The operation only works with <see cref="T:System.UInt32"/> values, so -1 always indicates that the item was not found.</remarks>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Decrement(System.String,System.UInt32)">
            <summary>
            Increments the value of the specified key by the given amount. 
            The operation is atomic and happens on the server.
            A non existent value at key starts at 0
            </summary>
            <param name="key">The identifier for the item to increment.</param>
            <param name="amount">The amount by which the client wants to decrease the item.</param>
            <returns>
            The new value of the item or -1 if not found.
            </returns>
            <remarks>The item must be inserted into the cache before it can be changed. The item must be inserted as a <see cref="T:System.String"/>. The operation only works with <see cref="T:System.UInt32"/> values, so -1 always indicates that the item was not found.</remarks>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Add``1(System.String,``0)">
            <summary>
            Adds a new item into the cache at the specified cache key only if the cache is empty.
            </summary>
            <param name="key">The key used to reference the item.</param>
            <param name="value">The object to be inserted into the cache.</param>
            <returns>
            true if the item was successfully stored in the cache; false otherwise.
            </returns>
            <remarks>The item does not expire unless it is removed due memory pressure.</remarks>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Set``1(System.String,``0)">
            <summary>
            Sets an item into the cache at the cache key specified regardless if it already exists or not.
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.Replace``1(System.String,``0)">
            <summary>
            Replaces the item at the cachekey specified only if an items exists at the location already. 
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.FlushAll">
            <summary>
            Invalidates all data on the cache.
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Retrieves multiple items from the cache. 
            The default value of T is set for all keys that do not exist.
            </summary>
            <param name="keys">The list of identifiers for the items to retrieve.</param>
            <returns>
            a Dictionary holding all items indexed by their key.
            </returns>
        </member>
        <member name="M:ServiceStack.Caching.ICacheClient.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>
            Sets multiple items to the cache. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values">The values.</param>
        </member>
        <member name="T:ServiceStack.Caching.ICacheClientExtended">
            <summary>
            Extend ICacheClient API with shared, non-core features
            </summary>
        </member>
        <member name="T:ServiceStack.Caching.IMemcachedClient">
            <summary>
            A light interface over a cache client.
            This interface was inspired by Enyim.Caching.MemcachedClient
            
            Only the methods that are intended to be used are required, if you require
            extra functionality you can uncomment the unused methods below as they have been
            implemented in DdnMemcachedClient
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.Remove(System.String)">
            <summary>
            Removes the specified item from the cache.
            </summary>
            <param name="key">The identifier for the item to delete.</param>
            <returns>
            true if the item was successfully removed from the cache; false otherwise.
            </returns>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.RemoveAll(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Removes the cache for all the keys provided.
            </summary>
            <param name="keys">The keys.</param>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.Get(System.String)">
            <summary>
            Retrieves the specified item from the cache.
            </summary>
            <param ICTname="key">The identifier for the item to retrieve.</param>
            <returns>
            The retrieved item, or <value>null</value> if the key was not found.
            </returns>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.Increment(System.String,System.UInt32)">
            <summary>
            Increments the value of the specified key by the given amount. The operation is atomic and happens on the server.
            </summary>
            <param name="key">The identifier for the item to increment.</param>
            <param name="amount">The amount by which the client wants to increase the item.</param>
            <returns>
            The new value of the item or -1 if not found.
            </returns>
            <remarks>The item must be inserted into the cache before it can be changed. The item must be inserted as a <see cref="T:System.String"/>. The operation only works with <see cref="T:System.UInt32"/> values, so -1 always indicates that the item was not found.</remarks>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.Decrement(System.String,System.UInt32)">
            <summary>
            Increments the value of the specified key by the given amount. The operation is atomic and happens on the server.
            </summary>
            <param name="key">The identifier for the item to increment.</param>
            <param name="amount">The amount by which the client wants to decrease the item.</param>
            <returns>
            The new value of the item or -1 if not found.
            </returns>
            <remarks>The item must be inserted into the cache before it can be changed. The item must be inserted as a <see cref="T:System.String"/>. The operation only works with <see cref="T:System.UInt32"/> values, so -1 always indicates that the item was not found.</remarks>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.Add(System.String,System.Object)">
            <summary>
            Inserts an item into the cache with a cache key to reference its location.
            </summary>
            <param name="key">The key used to reference the item.</param>
            <param name="value">The object to be inserted into the cache.</param>
            <returns>
            true if the item was successfully stored in the cache; false otherwise.
            </returns>
            <remarks>The item does not expire unless it is removed due memory pressure.</remarks>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.Add(System.String,System.Object,System.DateTime)">
            <summary>
            Inserts an item into the cache with a cache key to reference its location.
            </summary>
            <param name="key">The key used to reference the item.</param>
            <param name="value">The object to be inserted into the cache.</param>
            <param name="expiresAt">The time when the item is invalidated in the cache.</param>
            <returns>true if the item was successfully stored in the cache; false otherwise.</returns>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.FlushAll">
            <summary>
            Removes all data from the cache.
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.IMemcachedClient.GetAll(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Retrieves multiple items from the cache.
            </summary>
            <param name="keys">The list of identifiers for the items to retrieve.</param>
            <returns>
            a Dictionary holding all items indexed by their key.
            </returns>
        </member>
        <member name="M:ServiceStack.Caching.IRemoveByPattern.RemoveByPattern(System.String)">
            <summary>
            Removes items from cache that have keys matching the specified wildcard pattern
            </summary>
            <param name="pattern">The wildcard, where "*" means any sequence of characters and "?" means any single character.</param>
        </member>
        <member name="M:ServiceStack.Caching.IRemoveByPattern.RemoveByRegex(System.String)">
            <summary>
            Removes items from the cache based on the specified regular expression pattern
            </summary>
            <param name="regex">Regular expression pattern to search cache keys</param>
        </member>
        <member name="T:ServiceStack.Caching.ISession">
            <summary>
            A Users Session
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.ISession.Set``1(System.String,``0)">
            <summary>
            Set a typed value at key
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
        </member>
        <member name="M:ServiceStack.Caching.ISession.Get``1(System.String)">
            <summary>
            Get a typed value at key
            </summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Caching.ISession.Remove(System.String)">
            <summary>
            Remove the value at key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Caching.ISession.RemoveAll">
            <summary>
            Delete all Cache Entries (requires ICacheClient that implements IRemoveByPattern)
            </summary>
        </member>
        <member name="P:ServiceStack.Caching.ISession.Item(System.String)">
            <summary>
            Store any object at key
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Caching.ISessionFactory">
            <summary>
            Retrieves a User Session
            </summary>
        </member>
        <member name="M:ServiceStack.Caching.ISessionFactory.GetOrCreateSession(ServiceStack.Web.IRequest,ServiceStack.Web.IResponse)">
            <summary>
            Gets the session for this request, creates one if it doesn't exist.
            </summary>
            <param name="httpReq"></param>
            <param name="httpRes"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Caching.ISessionFactory.GetOrCreateSession">
            <summary>
            Gets the session for this request, creates one if it doesn't exist.
            Only for ASP.NET apps. Uses the HttpContext.Current singleton.
            </summary>
        </member>
        <member name="T:ServiceStack.Configuration.IContainerAdapter">
            <summary>
            Allow delegation of dependencies to other IOC's
            </summary>
        </member>
        <member name="M:ServiceStack.Configuration.IResolver.TryResolve``1">
            <summary>
            Resolve a dependency from the AppHost's IOC
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Configuration.IContainerAdapter.Resolve``1">
            <summary>
            Resolve Constructor Dependency
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.DataAnnotations.BelongToAttribute">
            <summary>
            BelongToAttribute
            Use to indicate that a join column belongs to another table.
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.ComputeAttribute">
            <summary>
            Compute attribute.
            Use to indicate that a property is a Calculated Field 
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.DecimalLengthAttribute">
            <summary>
            Decimal length attribute.
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.ExcludeAttribute">
            <summary>
            Mark types that are to be excluded from specified features
            </summary>
        </member>
        <member name="P:ServiceStack.DataAnnotations.ForeignKeyAttribute.ForeignKeyName">
            <summary>
            Explicit foreign key name. If it's null, or empty, the FK name will be autogenerated as before.
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.HashKeyAttribute">
            <summary>
            Hash Key Attribute used to specify which property is the HashKey, e.g. in DynamoDb.
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.IgnoreAttribute">
            <summary>
            IgnoreAttribute
            Use to indicate that a property is not a field  in the table
            properties with this attribute are ignored when building sql sentences
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.MetaAttribute">
            <summary>
            Decorate any type or property with adhoc info
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.PrimaryKeyAttribute">
            <summary>
            Primary key attribute.
            use to indicate that property is part of the pk
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.RangeKeyAttribute">
            <summary>
            Range Key Attribute used to specify which property is the RangeKey, e.g. in DynamoDb.
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.RowVersionAttribute">
            <summary>
            Used to indicate that property is a row version incremented automatically by the database
            </summary>
        </member>
        <member name="T:ServiceStack.DataAnnotations.SchemaAttribute">
            <summary>
            Used to annotate an Entity with its DB schema
            </summary>
        </member>
        <!-- 对于成员“T:ServiceStack.DataAnnotations.SequenceAttribute”忽略有格式错误的 XML 注释 -->
        <member name="T:ServiceStack.Data.IEntityStore`1">
            <summary>
            For providers that want a cleaner API with a little more perf
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.ErrorResponse">
            <summary>
            Generic ResponseStatus for when Response Type can't be inferred.
            In schemaless formats like JSON, JSV it has the same shape as a typed Response DTO
            </summary>
        </member>
        <member name="T:ServiceStack.IHasResponseStatus">
            <summary>
            Contract indication that the Response DTO has a ResponseStatus
            </summary>
        </member>
        <member name="T:ServiceStack.IServiceGateway">
            <summary>
            The minimal API Surface to capture the most common SYNC requests.
            Convenience extensions over these core API's available in ServiceGatewayExtensions
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGateway.Send``1(System.Object)">
            <summary>
            Normal Request/Reply Services
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGateway.SendAll``1(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Auto Batched Request/Reply Requests
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGateway.Publish(System.Object)">
            <summary>
            OneWay Service
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGateway.PublishAll(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Auto Batched OneWay Requests
            </summary>
        </member>
        <member name="M:ServiceStack.IRequiresSchema.InitSchema">
            <summary>
            Unifed API to create any missing Tables, Data Structure Schema 
            or perform any other tasks dependencies require to run at Startup.
            </summary>
        </member>
        <member name="T:ServiceStack.ISequenceSource">
            <summary>
            Provide unique, incrementing sequences. Used in PocoDynamo.
            </summary>
        </member>
        <member name="T:ServiceStack.IService">
            <summary>
            Marker interfaces
            </summary>
        </member>
        <member name="T:ServiceStack.IServiceGatewayAsync">
            <summary>
            The minimal API Surface to capture the most common ASYNC requests.
            Convenience extensions over these core API's available in ServiceGatewayExtensions
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGatewayAsync.SendAsync``1(System.Object,System.Threading.CancellationToken)">
            <summary>
            Normal Request/Reply Services
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGatewayAsync.SendAllAsync``1(System.Collections.Generic.IEnumerable{System.Object},System.Threading.CancellationToken)">
            <summary>
            Auto Batched Request/Reply Requests
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGatewayAsync.PublishAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            OneWay Service
            </summary>
        </member>
        <member name="M:ServiceStack.IServiceGatewayAsync.PublishAllAsync(System.Collections.Generic.IEnumerable{System.Object},System.Threading.CancellationToken)">
            <summary>
            Auto Batched OneWay Requests
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.GenericLogger">
            <summary>
            Helper ILog implementation that reduces effort to extend or use without needing to impl each API
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.GenericLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.GenericLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.GenericLogger.Log(System.Object,System.Exception)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.GenericLogger.LogFormat(System.Object,System.Object[])">
            <summary>
            Logs the format.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.GenericLogger.Log(System.Object)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.LogManager">
            <summary>
            Logging API for this library. You can inject your own implementation otherwise
            will use the DebugLogFactory to write to System.Diagnostics.Debug
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.LogManager.GetLogger(System.Type)">
            <summary>
            Gets the logger.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.LogManager.GetLogger(System.String)">
            <summary>
            Gets the logger.
            </summary>
        </member>
        <member name="P:ServiceStack.Logging.LogManager.LogFactory">
            <summary>
            Gets or sets the log factory.
            Use this to override the factory that is used to create loggers
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.NullDebugLogger">
            <summary>
            Default logger is to System.Diagnostics.Debug.Print
            
            Made public so its testable
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.NullDebugLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.NullDebugLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.DebugLogger"/> class.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.NullDebugLogger.Log(System.Object,System.Exception)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.NullDebugLogger.LogFormat(System.Object,System.Object[])">
            <summary>
            Logs the format.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.NullDebugLogger.Log(System.Object)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.NullLogFactory">
            <summary>
            Creates a Debug Logger, that logs all messages to: System.Diagnostics.Debug
            
            Made public so its testable
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.StringBuilderLogFactory">
            <summary>
            StringBuilderLog writes to shared StringBuffer.
            Made public so its testable
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.StringBuilderLog.Log(System.Object,System.Exception)">
            <summary>
            Logs the specified message.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.StringBuilderLog.LogFormat(System.Object,System.Object[])">
            <summary>
            Logs the format.
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.StringBuilderLog.Log(System.Object)">
            <summary>
            Logs the specified message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:ServiceStack.Logging.TestLogFactory">
            <summary>
            Creates a test Logger, that stores all log messages in a member list
            </summary>
        </member>
        <member name="T:ServiceStack.Logging.TestLogger">
            <summary>
            Tests logger which  stores all log messages in a member list which can be examined later
            
            Made public so its testable
            </summary>
        </member>
        <member name="M:ServiceStack.Logging.TestLogger.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.TestLogger"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:ServiceStack.Logging.TestLogger.#ctor(System.Type)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.Logging.TestLogger"/> class.
            </summary>
            <param name="type">The type.</param>
        </member>
        <member name="M:ServiceStack.Logging.TestLogger.Log(ServiceStack.Logging.TestLogger.Levels,System.Object,System.Exception)">
            <summary>
            Logs the specified message.
            </summary>
            <param name="message">The message.</param>
            <param name="exception">The exception.</param>
        </member>
        <member name="M:ServiceStack.Logging.TestLogger.LogFormat(ServiceStack.Logging.TestLogger.Levels,System.Object,System.Object[])">
            <summary>
            Logs the format.
            </summary>
            <param name="message">The message.</param>
            <param name="args">The args.</param>
        </member>
        <member name="M:ServiceStack.Logging.TestLogger.Log(ServiceStack.Logging.TestLogger.Levels,System.Object)">
            <summary>
            Logs the specified message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="T:ServiceStack.Messaging.IMessageHandler">
            <summary>
            Single threaded message handler that can process all messages
            of a particular message type.
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageHandler.Process(ServiceStack.Messaging.IMessageQueueClient)">
            <summary>
            Process all messages pending
            </summary>
            <param name="mqClient"></param>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageHandler.ProcessQueue(ServiceStack.Messaging.IMessageQueueClient,System.String,System.Func{System.Boolean})">
            <summary>
            Process messages from a single queue.
            </summary>
            <param name="mqClient"></param>
            <param name="queueName">The queue to process</param>
            <param name="doNext">A predicate on whether to continue processing the next message if any</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageHandler.ProcessMessage(ServiceStack.Messaging.IMessageQueueClient,System.Object)">
            <summary>
            Process a single message
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageHandler.GetStats">
            <summary>
            Get Current Stats for this Message Handler
            </summary>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.Messaging.IMessageHandler.MessageType">
            <summary>
            The type of the message this handler processes
            </summary>
        </member>
        <member name="P:ServiceStack.Messaging.IMessageHandler.MqClient">
            <summary>
            The MqClient processing the message
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.Publish(System.String,ServiceStack.Messaging.IMessage)">
            <summary>
            Publish the specified message into the durable queue @queueName
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.Notify(System.String,ServiceStack.Messaging.IMessage)">
            <summary>
            Publish the specified message into the transient queue @queueName
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.Get``1(System.String,System.Nullable{System.TimeSpan})">
            <summary>
            Synchronous blocking get.
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.GetAsync``1(System.String)">
            <summary>
            Non blocking get message
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.Ack(ServiceStack.Messaging.IMessage)">
            <summary>
            Acknowledge the message has been successfully received or processed
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.Nak(ServiceStack.Messaging.IMessage,System.Boolean,System.Exception)">
            <summary>
            Negative acknowledgement the message was not processed correctly
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.CreateMessage``1(System.Object)">
            <summary>
            Create a typed message from a raw MQ Response artefact
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageQueueClient.GetTempQueueName">
            <summary>
            Create a temporary Queue for Request / Reply
            </summary>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Messaging.IMessageService">
            <summary>
            Simple definition of an MQ Host
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.RegisterHandler``1(System.Func{ServiceStack.Messaging.IMessage{``0},System.Object})">
            <summary>
            Register DTOs and hanlders the MQ Host will process
            </summary>
            <typeparam name="T"></typeparam>
            <param name="processMessageFn"></param>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.RegisterHandler``1(System.Func{ServiceStack.Messaging.IMessage{``0},System.Object},System.Action{ServiceStack.Messaging.IMessageHandler,ServiceStack.Messaging.IMessage{``0},System.Exception})">
            <summary>
            Register DTOs and hanlders the MQ Host will process
            </summary>
            <typeparam name="T"></typeparam>
            <param name="processMessageFn"></param>
            <param name="processExceptionEx"></param>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.GetStats">
            <summary>
            Get Total Current Stats for all Message Handlers
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.GetStatus">
            <summary>
            Get the status of the service. Potential Statuses: Disposed, Stopped, Stopping, Starting, Started
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.GetStatsDescription">
            <summary>
            Get a Stats dump
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.Start">
            <summary>
            Start the MQ Host if not already started.
            </summary>
        </member>
        <member name="M:ServiceStack.Messaging.IMessageService.Stop">
            <summary>
            Stop the MQ Host if not already stopped. 
            </summary>
        </member>
        <member name="P:ServiceStack.Messaging.IMessageService.MessageFactory">
            <summary>
            Factory to create consumers and producers that work with this service
            </summary>
        </member>
        <member name="P:ServiceStack.Messaging.IMessageService.RegisteredTypes">
            <summary>
            Get a list of all message types registered on this MQ Host
            </summary>
        </member>
        <member name="T:ServiceStack.Messaging.Message`1">
            <summary>
            Basic implementation of IMessage[T]
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Messaging.QueueNames`1">
            <summary>
            Util static generic class to create unique queue names for types
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Messaging.QueueNames">
            <summary>
            Util class to create unique queue names for runtime types
            </summary>
        </member>
        <member name="T:ServiceStack.Messaging.UnRetryableMessagingException">
            <summary>
            For messaging exceptions that should by-pass the messaging service's configured
            retry attempts and store the message straight into the DLQ
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.Generic.IRedisList`1">
            <summary>
            Wrap the common redis list operations under a IList[string] interface.
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.Generic.IRedisTypedTransaction`1">
            <summary>
            Redis transaction for typed client
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Redis.Generic.IRedisTypedQueueableOperation`1">
            <summary>
            interface to queueable operation using typed redis client
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Redis.Generic.IRedisTypedPipeline`1">
            <summary>
            Interface to redis typed pipeline
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.Pipeline.IRedisPipelineShared">
            <summary>
            Pipeline interface shared by typed and non-typed pipelines
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.Pipeline.IRedisQueueCompletableOperation">
            <summary>
            Interface to operations that allow queued commands to be completed
            </summary>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClient.As``1">
            <summary>
            Returns a high-level typed client API
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientCacheManager.GetClient">
            <summary>
            Returns a Read/Write client (The default) using the hosts defined in ReadWriteHosts
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientCacheManager.GetReadOnlyClient">
            <summary>
            Returns a ReadOnly client using the hosts defined in ReadOnlyHosts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientCacheManager.GetCacheClient">
            <summary>
            Returns a Read/Write ICacheClient (The default) using the hosts defined in ReadWriteHosts
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientCacheManager.GetReadOnlyCacheClient">
            <summary>
            Returns a ReadOnly ICacheClient using the hosts defined in ReadOnlyHosts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientsManager.GetClient">
            <summary>
            Returns a Read/Write client (The default) using the hosts defined in ReadWriteHosts
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientsManager.GetReadOnlyClient">
            <summary>
            Returns a ReadOnly client using the hosts defined in ReadOnlyHosts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientsManager.GetCacheClient">
            <summary>
            Returns a Read/Write ICacheClient (The default) using the hosts defined in ReadWriteHosts
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisClientsManager.GetReadOnlyCacheClient">
            <summary>
            Returns a ReadOnly ICacheClient using the hosts defined in ReadOnlyHosts.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Redis.IRedisSubscription.SubscribeToChannels(System.String[])">
            <summary>
            Subscribe to channels by name
            </summary>
            <param name="channels"></param>
        </member>
        <member name="M:ServiceStack.Redis.IRedisSubscription.SubscribeToChannelsMatching(System.String[])">
            <summary>
            Subscribe to channels matching the supplied patterns
            </summary>
            <param name="patterns"></param>
        </member>
        <member name="P:ServiceStack.Redis.IRedisSubscription.SubscriptionCount">
            <summary>
            The number of active subscriptions this client has
            </summary>
        </member>
        <member name="P:ServiceStack.Redis.IRedisSubscription.OnSubscribe">
            <summary>
            Registered handler called after client *Subscribes* to each new channel
            </summary>
        </member>
        <member name="P:ServiceStack.Redis.IRedisSubscription.OnMessage">
            <summary>
            Registered handler called when each message is received
            </summary>
        </member>
        <member name="P:ServiceStack.Redis.IRedisSubscription.OnUnSubscribe">
            <summary>
            Registered handler called when each channel is unsubscribed
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.IRedisTransaction">
            <summary>
            Interface to redis transaction
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.IRedisTransactionBase">
            <summary>
            Base transaction interface, shared by typed and non-typed transactions
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.Pipeline.IRedisQueueableOperation">
            <summary>
            interface to operation that can queue commands
            </summary>
        </member>
        <member name="T:ServiceStack.Redis.Pipeline.IRedisPipeline">
            <summary>
            Interface to redis pipeline
            </summary>
        </member>
        <member name="T:ServiceStack.RequestLogEntry">
            <summary>
            A log entry added by the IRequestLogger
            </summary>
        </member>
        <member name="T:ServiceStack.ResponseError">
            <summary>
            Error information pertaining to a particular named field.
            Used for returning multiple field validation errors.s
            </summary>
        </member>
        <member name="T:ServiceStack.ResponseStatus">
            <summary>
            Common ResponseStatus class that should be present on all response DTO's
            </summary>
        </member>
        <member name="M:ServiceStack.ResponseStatus.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.ResponseStatus"/> class.
            
            A response status without an errorcode == success
            </summary>
        </member>
        <member name="M:ServiceStack.ResponseStatus.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.ResponseStatus"/> class.
            A response status with an errorcode == failure
            </summary>
        </member>
        <member name="M:ServiceStack.ResponseStatus.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ServiceStack.ResponseStatus"/> class.
            A response status with an errorcode == failure
            </summary>
        </member>
        <member name="P:ServiceStack.ResponseStatus.ErrorCode">
            <summary>
            Holds the custom ErrorCode enum if provided in ValidationException
            otherwise will hold the name of the Exception type, e.g. typeof(Exception).Name
            
            A value of non-null means the service encountered an error while processing the request.
            </summary>
        </member>
        <member name="P:ServiceStack.ResponseStatus.Message">
            <summary>
            A human friendly error message
            </summary>
        </member>
        <member name="P:ServiceStack.ResponseStatus.StackTrace">
            <summary>
            The Server StackTrace when DebugMode is enabled
            </summary>
        </member>
        <member name="P:ServiceStack.ResponseStatus.Errors">
            <summary>
            For multiple detailed validation errors.
            Can hold a specific error message for each named field.
            </summary>
        </member>
        <member name="P:ServiceStack.ResponseStatus.Meta">
            <summary>
            For additional custom metadata about the error
            </summary>
        </member>
        <member name="T:ServiceStack.RestrictAttribute">
            <summary>
            Decorate on Request DTO's to alter the accessibility of a service and its visibility on /metadata pages
            </summary>
        </member>
        <member name="M:ServiceStack.RestrictAttribute.#ctor(ServiceStack.RequestAttributes[])">
            <summary>
            Restrict access and metadata visibility to any of the specified access scenarios
            </summary>
            <value>The restrict access to scenarios.</value>
        </member>
        <member name="M:ServiceStack.RestrictAttribute.#ctor(ServiceStack.RequestAttributes[],ServiceStack.RequestAttributes[])">
            <summary>
            Restrict access and metadata visibility to any of the specified access scenarios
            </summary>
            <value>The restrict access to scenarios.</value>
        </member>
        <member name="M:ServiceStack.RestrictAttribute.ToAllowedFlagsSet(ServiceStack.RequestAttributes[])">
            <summary>
            Returns the allowed set of scenarios based on the user-specified restrictions
            </summary>
            <param name="restrictToAny"></param>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.VisibleInternalOnly">
            <summary>
            Allow access but hide from metadata to requests from Localhost only
            </summary>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.VisibleLocalhostOnly">
            <summary>
            Allow access but hide from metadata to requests from Localhost and Local Intranet only
            </summary>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.LocalhostOnly">
            <summary>
            Restrict access and hide from metadata to requests from Localhost only
            </summary>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.InternalOnly">
            <summary>
            Restrict access and hide from metadata to requests from Localhost and Local Intranet only
            </summary>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.ExternalOnly">
            <summary>
            Restrict access and hide from metadata to requests from External only
            </summary>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.AccessTo">
            <summary>
            Sets a single access restriction
            </summary>
            <value>Restrict Access to.</value>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.AccessibleToAny">
            <summary>
            Restrict access to any of the specified access scenarios
            </summary>
            <value>Access restrictions</value>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.VisibilityTo">
            <summary>
            Sets a single metadata Visibility restriction
            </summary>
            <value>Restrict metadata Visibility to.</value>
        </member>
        <member name="P:ServiceStack.RestrictAttribute.VisibleToAny">
            <summary>
            Restrict metadata visibility to any of the specified access scenarios
            </summary>
            <value>Visibility restrictions</value>
        </member>
        <member name="M:ServiceStack.RestrictExtensions.ToAllowedFlagsSet(ServiceStack.RequestAttributes)">
            <summary>
            Converts from a User intended restriction to a flag with all the allowed attribute flags set, e.g:
            
            If No Network restrictions were specified all Network access types are allowed, e.g:
                restrict EndpointAttributes.None => ... 111
            
            If a Network restriction was specified, only it will be allowed, e.g:
                restrict EndpointAttributes.LocalSubnet => ... 010
            
            The returned Enum will have a flag with all the allowed attributes set
            </summary>
            <param name="restrictTo"></param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.RouteAttribute">
            <summary>
            	Used to decorate Request DTO's to associate a RESTful request 
            	path mapping with a service.  Multiple attributes can be applied to 
            	each request DTO, to map multiple paths to the service.
            </summary>
        </member>
        <member name="M:ServiceStack.RouteAttribute.#ctor(System.String)">
            <summary>
            	<para>Initializes an instance of the <see cref="T:ServiceStack.RouteAttribute"/> class.</para>
            </summary>
            <param name="path">
            	<para>The path template to map to the request.  See 
            	<see cref="P:ServiceStack.RouteAttribute.Path">RouteAttribute.Path</see>
            	for details on the correct format.</para>
            </param>
        </member>
        <member name="M:ServiceStack.RouteAttribute.#ctor(System.String,System.String)">
            <summary>
            	<para>Initializes an instance of the <see cref="T:ServiceStack.RouteAttribute"/> class.</para>
            </summary>
            <param name="path">
            	<para>The path template to map to the request.  See 
            	<see cref="P:ServiceStack.RouteAttribute.Path">RouteAttribute.Path</see>
            	for details on the correct format.</para>
            </param>
            <param name="verbs">A comma-delimited list of HTTP verbs supported by the 
            	service.  If unspecified, all verbs are assumed to be supported.</param>
        </member>
        <member name="P:ServiceStack.RouteAttribute.Path">
            <summary>
            	Gets or sets the path template to be mapped to the request.
            </summary>
            <value>
            	A <see cref="T:System.String"/> value providing the path mapped to
            	the request.  Never <see langword="null"/>.
            </value>
            <remarks>
            	<para>Some examples of valid paths are:</para>
            
            	<list>
            		<item>"/Inventory"</item>
            		<item>"/Inventory/{Category}/{ItemId}"</item>
            		<item>"/Inventory/{ItemPath*}"</item>
            	</list>
            
            	<para>Variables are specified within "{}"
            	brackets.  Each variable in the path is mapped to the same-named property 
            	on the request DTO.  At runtime, ServiceStack will parse the 
            	request URL, extract the variable values, instantiate the request DTO,
            	and assign the variable values into the corresponding request properties,
            	prior to passing the request DTO to the service object for processing.</para>
            
            	<para>It is not necessary to specify all request properties as
            	variables in the path.  For unspecified properties, callers may provide 
            	values in the query string.  For example: the URL 
            	"http://services/Inventory?Category=Books&amp;ItemId=12345" causes the same 
            	request DTO to be processed as "http://services/Inventory/Books/12345", 
            	provided that the paths "/Inventory" (which supports the first URL) and 
            	"/Inventory/{Category}/{ItemId}" (which supports the second URL)
            	are both mapped to the request DTO.</para>
            
            	<para>Please note that while it is possible to specify property values
            	in the query string, it is generally considered to be less RESTful and
            	less desirable than to specify them as variables in the path.  Using the 
            	query string to specify property values may also interfere with HTTP
            	caching.</para>
            
            	<para>The final variable in the path may contain a "*" suffix
            	to grab all remaining segments in the path portion of the request URL and assign
            	them to a single property on the request DTO.
            	For example, if the path "/Inventory/{ItemPath*}" is mapped to the request DTO,
            	then the request URL "http://services/Inventory/Books/12345" will result
            	in a request DTO whose ItemPath property contains "Books/12345".
            	You may only specify one such variable in the path, and it must be positioned at
            	the end of the path.</para>
            </remarks>
        </member>
        <member name="P:ServiceStack.RouteAttribute.Summary">
            <summary>
               Gets or sets short summary of what the route does.
            </summary>
        </member>
        <member name="P:ServiceStack.RouteAttribute.Notes">
            <summary>
               Gets or sets longer text to explain the behaviour of the route. 
            </summary>
        </member>
        <member name="P:ServiceStack.RouteAttribute.Verbs">
            <summary>
            	Gets or sets a comma-delimited list of HTTP verbs supported by the service, such as
            	"GET,PUT,POST,DELETE".
            </summary>
            <value>
            	A <see cref="T:System.String"/> providing a comma-delimited list of HTTP verbs supported
            	by the service, <see langword="null"/> or empty if all verbs are supported.
            </value>
        </member>
        <member name="P:ServiceStack.RouteAttribute.Priority">
            <summary>
            Used to rank the precedences of route definitions in reverse routing. 
            i.e. Priorities below 0 are auto-generated have less precedence.
            </summary>
        </member>
        <member name="T:ServiceStack.FallbackRouteAttribute">
            <summary>
            Fallback routes have the lowest precedence, i.e. after normal Routes, static files or any matching Catch All Handlers.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.ICookies.DeleteCookie(System.String)">
            <summary>
            Adds an expired Set-Cookie instruction for clients to delete this Cookie
            </summary>
        </member>
        <member name="M:ServiceStack.Web.ICookies.AddPermanentCookie(System.String,System.String,System.Nullable{System.Boolean})">
            <summary>
            Adds a new Set-Cookie instruction for ss-pid
            </summary>
        </member>
        <member name="M:ServiceStack.Web.ICookies.AddSessionCookie(System.String,System.String,System.Nullable{System.Boolean})">
            <summary>
            Adds a new Set-Cookie instruction for ss-id
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IHasRequestFilter">
            <summary>
            This interface can be implemented by an attribute
            which adds an request filter for the specific request DTO the attribute marked.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IHasRequestFilter.RequestFilter(ServiceStack.Web.IRequest,ServiceStack.Web.IResponse,System.Object)">
            <summary>
            The request filter is executed before the service.
            </summary>
            <param name="req">The http request wrapper</param>
            <param name="res">The http response wrapper</param>
            <param name="requestDto">The request DTO</param>
        </member>
        <member name="M:ServiceStack.Web.IHasRequestFilter.Copy">
            <summary>
            A new shallow copy of this filter is used on every request.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.Web.IHasRequestFilter.Priority">
            <summary>
            Order in which Request Filters are executed. 
            &lt;0 Executed before global request filters
            &gt;0 Executed after global request filters
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IHasResponseFilter">
            <summary>
            This interface can be implemented by an attribute
            which adds an response filter for the specific response DTO the attribute marked.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IHasResponseFilter.ResponseFilter(ServiceStack.Web.IRequest,ServiceStack.Web.IResponse,System.Object)">
            <summary>
            The response filter is executed after the service
            </summary>
            <param name="req">The http request wrapper</param>
            <param name="res">The http response wrapper</param>
        </member>
        <member name="M:ServiceStack.Web.IHasResponseFilter.Copy">
            <summary>
            A new shallow copy of this filter is used on every request.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.Web.IHasResponseFilter.Priority">
            <summary>
            Order in which Response Filters are executed. 
            &lt;0 Executed before global response filters
            &gt;0 Executed after global response filters
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.Status">
            <summary>
            The HTTP Response Status
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.StatusCode">
            <summary>
            The HTTP Response Status Code
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.StatusDescription">
            <summary>
            The HTTP Status Description
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.ContentType">
            <summary>
            The HTTP Response ContentType
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.Headers">
            <summary>
            Additional HTTP Headers
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.Cookies">
            <summary>
            Additional HTTP Cookies
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.Response">
            <summary>
            Response DTO
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.ResponseFilter">
            <summary>
            if not provided, get's injected by ServiceStack
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.RequestContext">
            <summary>
            Holds the request call context
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.PaddingLength">
            <summary>
            The padding length written with the body, to be added to ContentLength of body
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpResult.ResultScope">
            <summary>
            Serialize the Response within the specified scope
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IHttpRequest">
            <summary>
            A thin wrapper around ASP.NET or HttpListener's HttpRequest
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IRequest">
            <summary>
            A thin wrapper around each host's Request e.g: ASP.NET, HttpListener, MQ, etc
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IRequest.GetRawBody">
            <summary>
            The entire string contents of Request.InputStream
            </summary>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.Web.IRequest.OriginalRequest">
            <summary>
            The underlying ASP.NET or HttpListener HttpRequest
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.OperationName">
            <summary>
            The name of the service being called (e.g. Request DTO Name)
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.Verb">
            <summary>
            The Verb / HttpMethod or Action for this request
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.RequestPreferences">
            <summary>
            Optional preferences for the processing of this Request
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.Dto">
            <summary>
            The Request DTO, after it has been deserialized.
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.ContentType">
            <summary>
            The request ContentType
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.ResponseContentType">
            <summary>
            The expected Response ContentType for this request
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.HasExplicitResponseContentType">
            <summary>
            Whether the ResponseContentType has been explicitly overrided or whether it was just the default
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.Items">
            <summary>
            Attach any data to this request that all filters and services can access.
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.UseBufferedStream">
            <summary>
            Buffer the Request InputStream so it can be re-read
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.UserHostAddress">
            <summary>
            The Remote Ip as reported by Request.UserHostAddress
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.RemoteIp">
            <summary>
            The Remote Ip as reported by X-Forwarded-For, X-Real-IP or Request.UserHostAddress
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.Authorization">
            <summary>
            The value of the Authorization Header used to send the Api Key, null if not available
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.IsSecureConnection">
            <summary>
            e.g. is https or not
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.Files">
            <summary>
            Access to the multi-part/formdata files posted on this request
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequest.UrlReferrer">
            <summary>
            The value of the Referrer, null if not available
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.HttpResponse">
            <summary>
            The HttpResponse
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.HttpMethod">
            <summary>
            The HTTP Verb
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.XForwardedFor">
            <summary>
            The IP Address of the X-Forwarded-For header, null if null or empty
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.XForwardedPort">
            <summary>
            The Port number of the X-Forwarded-Port header, null if null or empty
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.XForwardedProtocol">
            <summary>
            The http or https scheme of the X-Forwarded-Proto header, null if null or empty
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.XRealIp">
            <summary>
            The value of the X-Real-IP header, null if null or empty
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IHttpRequest.Accept">
            <summary>
            The value of the Accept HTTP Request Header
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IHttpResponse">
            <summary>
            A thin wrapper around ASP.NET or HttpListener's HttpResponse
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IResponse">
            <summary>
            A thin wrapper around each host's Response e.g: ASP.NET, HttpListener, MQ, etc
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IResponse.Write(System.String)">
            <summary>
            Write once to the Response Stream then close it. 
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:ServiceStack.Web.IResponse.Close">
            <summary>
            Signal that this response has been handled and no more processing should be done.
            When used in a request or response filter, no more filters or processing is done on this request.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IResponse.End">
            <summary>
            Calls Response.End() on ASP.NET HttpResponse otherwise is an alias for Close().
            Useful when you want to prevent ASP.NET to provide it's own custom error page.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IResponse.Flush">
            <summary>
            Response.Flush() and OutputStream.Flush() seem to have different behaviour in ASP.NET
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IResponse.OriginalResponse">
            <summary>
            The underlying ASP.NET or HttpListener HttpResponse
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IResponse.Dto">
            <summary>
            The Response DTO
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IResponse.UseBufferedStream">
            <summary>
            Buffer the Response OutputStream so it can be written in 1 batch
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IResponse.IsClosed">
            <summary>
            Gets a value indicating whether this instance is closed.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IHttpResponse.SetCookie(System.Net.Cookie)">
            <summary>
            Adds a new Set-Cookie instruction to Response
            </summary>
            <param name="cookie"></param>
        </member>
        <member name="M:ServiceStack.Web.IHttpResponse.ClearCookies">
            <summary>
            Removes all pending Set-Cookie instructions 
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IPartialWriter.WritePartialTo(ServiceStack.Web.IResponse)">
            <summary>
            Write a partial content result
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IPartialWriter.IsPartialRequest">
            <summary>
            Whether this HttpResult allows Partial Response
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IRequestLogger">
            <summary>
            Log every service request
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IRequestLogger.Log(ServiceStack.Web.IRequest,System.Object,System.Object,System.TimeSpan)">
            <summary>
            Log a request
            </summary>
            <param name="request">The RequestContext</param>
            <param name="requestDto">Request DTO</param>
            <param name="response">Response DTO or Exception</param>
            <param name="elapsed">How long did the Request take</param>
        </member>
        <member name="M:ServiceStack.Web.IRequestLogger.GetLatestLogs(System.Nullable{System.Int32})">
            <summary>
            View the most recent logs
            </summary>
            <param name="take"></param>
            <returns></returns>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.EnableSessionTracking">
            <summary>
            Turn On/Off Session Tracking
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.EnableRequestBodyTracking">
            <summary>
            Turn On/Off Raw Request Body Tracking
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.EnableResponseTracking">
            <summary>
            Turn On/Off Tracking of Responses
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.EnableErrorTracking">
            <summary>
            Turn On/Off Tracking of Exceptions
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.RequiredRoles">
            <summary>
            Limit access to /requestlogs service to role
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.ExcludeRequestDtoTypes">
            <summary>
            Don't log requests of these types.
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequestLogger.HideRequestBodyForRequestDtoTypes">
            <summary>
            Don't log request bodys for services with sensitive information.
            By default Auth and Registration requests are hidden.
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IRequiresRequest">
            <summary>
            Implement on services that need access to the RequestContext
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IRequiresRequestStream">
            <summary>
            Implement on Request DTOs that need access to the raw Request Stream
            </summary>
        </member>
        <member name="P:ServiceStack.Web.IRequiresRequestStream.RequestStream">
            <summary>
            The raw Http Request Input Stream
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IServiceController">
            <summary>
            Responsible for executing the operation within the specified context.
            </summary>
            <value>The operation types.</value>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.GetRestPathForRequest(System.String,System.String)">
            <summary>
            Returns the first matching RestPath
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.ExecuteMessage(ServiceStack.Messaging.IMessage)">
            <summary>
            Executes the MQ DTO request.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.ExecuteMessage(ServiceStack.Messaging.IMessage,ServiceStack.Web.IRequest)">
            <summary>
            Executes the MQ DTO request with the supplied requestContext
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.Execute(System.Object,ServiceStack.Web.IRequest)">
            <summary>
            Executes the DTO request under the supplied requestContext.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.Execute(System.Object,ServiceStack.Web.IRequest,System.Boolean)">
            <summary>
            Executes the DTO request under supplied context and option to Execute Request/Response Filters.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.Execute(System.Object)">
            <summary>
            Executes the DTO request with an empty RequestContext.
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceController.Execute(ServiceStack.Web.IRequest,System.Boolean)">
            <summary>
            Executes the DTO request with the current HttpRequest and option to Execute Request/Response Filters.
            </summary>
        </member>
        <member name="T:ServiceStack.Web.IServiceRoutes">
            <summary>
            Allow the registration of user-defined routes for services
            </summary>
        </member>
        <member name="M:ServiceStack.Web.IServiceRoutes.Add``1(System.String)">
            <summary>
            	Maps the specified REST path to the specified request DTO.
            </summary>
            <typeparam name="TRequest">The type of request DTO to map 
            	the path to.</typeparam>
            <param name="restPath">The path to map the request DTO to.
            	See <see cref="P:ServiceStack.RouteAttribute.Path">RouteAttribute.Path</see>
            	for details on the correct format.</param>
            <returns>The same <see cref="T:ServiceStack.Web.IServiceRoutes"/> instance;
            	never <see langword="null"/>.</returns>
        </member>
        <member name="M:ServiceStack.Web.IServiceRoutes.Add``1(System.String,System.String)">
            <summary>
            	Maps the specified REST path to the specified request DTO, and
            	specifies the HTTP verbs supported by the path.
            </summary>
            <typeparam name="TRequest">The type of request DTO to map 
            	the path to.</typeparam>
            <param name="restPath">The path to map the request DTO to.
            	See <see cref="P:ServiceStack.RouteAttribute.Path">RouteAttribute.Path</see>
            	for details on the correct format.</param>
            <param name="verbs">
            	The comma-delimited list of HTTP verbs supported by the path, 
            	such as "GET,PUT,DELETE".  Specify empty or <see langword="null"/>
            	to indicate that all verbs are supported.
            </param>
            <returns>The same <see cref="T:ServiceStack.Web.IServiceRoutes"/> instance;
            	never <see langword="null"/>.</returns>
        </member>
        <member name="M:ServiceStack.Web.IServiceRoutes.Add(System.Type,System.String,System.String)">
            <summary>
            	Maps the specified REST path to the specified request DTO, 
            	specifies the HTTP verbs supported by the path, and indicates
            	the default MIME type of the returned response.
            </summary>
            <param name="requestType">
            	The type of request DTO to map the path to.
            </param>
            <param name="restPath">The path to map the request DTO to.
            	See <see cref="P:ServiceStack.RouteAttribute.Path">RouteAttribute.Path</see>
            	for details on the correct format.</param>
            <param name="verbs">
            	The comma-delimited list of HTTP verbs supported by the path, 
            	such as "GET,PUT,DELETE".
            </param>
            <returns>The same <see cref="T:ServiceStack.Web.IServiceRoutes"/> instance;
            	never <see langword="null"/>.</returns>
        </member>
        <member name="M:ServiceStack.Web.IServiceRoutes.Add(System.Type,System.String,System.String,System.Int32)">
            <summary>
            	Maps the specified REST path to the specified request DTO, 
            	specifies the HTTP verbs supported by the path, and indicates
            	the default MIME type of the returned response.
            </summary>
            <param name="priority">
                Used to rank the precedences of route definitions in reverse routing. 
                i.e. Priorities below 0 are auto-generated have less precedence.
            </param>
        </member>
        <member name="M:ServiceStack.Web.IServiceRoutes.Add(System.Type,System.String,System.String,System.String,System.String)">
            <summary>
            	Maps the specified REST path to the specified request DTO, 
            	specifies the HTTP verbs supported by the path, and indicates
            	the default MIME type of the returned response.
            </summary>
            <param name="requestType">
            	The type of request DTO to map the path to.
            </param>
            <param name="restPath">The path to map the request DTO to.
            	See <see cref="P:ServiceStack.RouteAttribute.Path">RouteAttribute.Path</see>
            	for details on the correct format.</param>
            <param name="verbs">
            	The comma-delimited list of HTTP verbs supported by the path, 
            	such as "GET,PUT,DELETE".
            </param>
            <param name="summary">
                The short summary of what the REST does. 
            </param>
            <param name="notes">
                The longer text to explain the behaviour of the REST. 
            </param>
            <returns>The same <see cref="T:ServiceStack.Web.IServiceRoutes"/> instance;
            	never <see langword="null"/>.</returns>
        </member>
        <member name="T:ServiceStack.Text.AssemblyUtils">
            <summary>
            Utils to load types
            </summary>
        </member>
        <member name="M:ServiceStack.Text.AssemblyUtils.FindType(System.String)">
            <summary>
            Find the type from the name supplied
            </summary>
            <param name="typeName">[typeName] or [typeName, assemblyName]</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.AssemblyUtils.MainInterface``1">
            <summary>
            The top-most interface of the given type, if any.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.AssemblyUtils.FindType(System.String,System.String)">
            <summary>
            Find type if it exists
            </summary>
            <param name="typeName"></param>
            <param name="assemblyName"></param>
            <returns>The type if it exists</returns>
        </member>
        <member name="M:ServiceStack.AutoMappingUtils.PopulateWith(System.Object)">
            <summary>
            Populate an object with Example data.
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.AutoMappingUtils.PopulateObjectInternal(System.Object,System.Collections.Generic.Dictionary{System.Type,System.Int32})">
            <summary>
            Populates the object with example data.
            </summary>
            <param name="obj"></param>
            <param name="recursionInfo">Tracks how deeply nested we are</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.Prepare(System.DateTime,System.Boolean)">
            <summary>
            If AlwaysUseUtc is set to true then convert all DateTime to UTC. If PreserveUtc is set to true then UTC dates will not convert to local
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.RepairXsdTimeSeparator(System.String)">
            <summary>
            Repairs an out-of-spec XML date/time string which incorrectly uses a space instead of a 'T' to separate the date from the time.
            These string are occasionally generated by SQLite and can cause errors in OrmLite when reading these columns from the DB.
            </summary>
            <param name="dateTimeStr">The XML date/time string to repair</param>
            <returns>The repaired string. If no repairs were made, the original string is returned.</returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.ParseWcfJsonDateOffset(System.String)">
            <summary>
            WCF Json format: /Date(unixts+0000)/
            </summary>
            <param name="wcfJsonDate"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DateTimeSerializer.ParseWcfJsonDate(System.String)">
            <summary>
            WCF Json format: /Date(unixts+0000)/
            </summary>
            <param name="wcfJsonDate"></param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.DeserializeTypeUtils.GetTypeStringConstructor(System.Type)">
            <summary>
            Get the type(string) constructor if exists
            </summary>
            <param name="type">The type.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Common.JsWriter.HasAnyEscapeChars(System.String)">
            <summary>
            micro optimizations: using flags instead of value.IndexOfAny(EscapeChars)
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Text.Controller.PathInfo">
            <summary>
            Class to hold  
            </summary>
        </member>
        <!-- 对于成员“M:ServiceStack.Text.Controller.PathInfo.Parse(System.String)”忽略有格式错误的 XML 注释 -->
        <member name="T:ServiceStack.Text.DateTimeExtensions">
            <summary>
            A fast, standards-based, serialization-issue free DateTime serailizer.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.CanCreateFromString(System.Type)">
            <summary>
            Determines whether this serializer can create the specified type from a string.
            </summary>
            <param name="type">The type.</param>
            <returns>
            	<c>true</c> if this instance [can create from string] the specified type; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.DeserializeFromString(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.DeserializeFromReader(System.IO.TextReader)">
            <summary>
            Deserializes from reader.
            </summary>
            <param name="reader">The reader.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.SerializeToString(`0)">
            <summary>
            Serializes to string.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.ITypeSerializer`1.SerializeToWriter(`0,System.IO.TextWriter)">
            <summary>
            Serializes to writer.
            </summary>
            <param name="value">The value.</param>
            <param name="writer">The writer.</param>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sTimeSpanHandler">
            <summary>
            Sets which format to use when serializing TimeSpans
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEmitCamelCaseNames">
            <summary>
            <see langword="true"/> if the <see cref="T:ServiceStack.Text.Common.ITypeSerializer"/> is configured
            to take advantage of <see cref="T:System.CLSCompliantAttribute"/> specification,
            to support user-friendly serialized formats, ie emitting camelCasing for JSON
            and parsing member names and enum values in a case-insensitive manner.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEmitLowercaseUnderscoreNames">
            <summary>
            <see langword="true"/> if the <see cref="T:ServiceStack.Text.Common.ITypeSerializer"/> is configured
            to support web-friendly serialized formats, ie emitting lowercase_underscore_casing for JSON
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sPropertyConvention">
            <summary>
            Define how property names are mapped during deserialization
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sThrowOnDeserializationError">
            <summary>
            Gets or sets a value indicating if the framework should throw serialization exceptions
            or continue regardless of deserialization errors. If <see langword="true"/>  the framework
            will throw; otherwise, it will parse as many fields as possible. The default is <see langword="false"/>.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sAlwaysUseUtc">
            <summary>
            Gets or sets a value indicating if the framework should always convert <see cref="T:System.DateTime"/> to UTC format instead of local time. 
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sSkipDateTimeConversion">
            <summary>
            Gets or sets a value indicating if the framework should skip automatic <see cref="T:System.DateTime"/> conversions.
            Dates will be handled literally, any included timezone encoding will be lost and the date will be treaded as DateTimeKind.Local
            Utc formatted input will result in DateTimeKind.Utc output. Any input without TZ data will be set DateTimeKind.Unspecified
            This will take precedence over other flags like AlwaysUseUtc 
            JsConfig.DateHandler = DateHandler.ISO8601 should be used when set true for consistent de/serialization.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sAssumeUtc">
            <summary>
            Gets or sets a value indicating if the framework should always assume <see cref="T:System.DateTime"/> is in UTC format if Kind is Unspecified. 
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sAppendUtcOffset">
            <summary>
            Gets or sets whether we should append the Utc offset when we serialize Utc dates. Defaults to no.
            Only supported for when the JsConfig.DateHandler == JsonDateHandler.TimestampOffset
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sEscapeUnicode">
            <summary>
            Gets or sets a value indicating if unicode symbols should be serialized as "\uXXXX".
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sOnDeserializationError">
            <summary>
            Gets or sets a value indicating if the framework should call an error handler when
            an exception happens during the deserialization.
            </summary>
            <remarks>Parameters have following meaning in order: deserialized entity, property name, parsed value, property type, caught exception.</remarks>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sIncludePublicFields">
            <summary>
            If set to true, Interface types will be prefered over concrete types when serializing.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sMaxDepth">
            <summary>
            Sets the maximum depth to avoid circular dependencies
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig.sModelFactory">
            <summary>
            Set this to enable your own type construction provider.
            This is helpful for integration with IoC containers where you need to call the container constructor.
            Return null if you don't know how to construct the type and the parameterless constructor will be used.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsConfig.PreferInterfaces">
            <summary>
            If set to true, Interface types will be prefered over concrete types when serializing.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.IncludeTypeInfo">
            <summary>
            Always emit type info for this type.  Takes precedence over ExcludeTypeInfo
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.ExcludeTypeInfo">
            <summary>
            Never emit type info for this type
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.EmitCamelCaseNames">
            <summary>
            <see langword="true"/> if the <see cref="T:ServiceStack.Text.Common.ITypeSerializer"/> is configured
            to take advantage of <see cref="T:System.CLSCompliantAttribute"/> specification,
            to support user-friendly serialized formats, ie emitting camelCasing for JSON
            and parsing member names and enum values in a case-insensitive manner.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.serializeFn">
            <summary>
            Define custom serialization fn for BCL Structs
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.rawSerializeFn">
            <summary>
            Define custom raw serialization fn
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.onSerializingFn">
            <summary>
            Define custom serialization hook
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.onSerializedFn">
            <summary>
            Define custom after serialization hook
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.deSerializeFn">
            <summary>
            Define custom deserialization fn for BCL Structs
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.rawDeserializeFn">
            <summary>
            Define custom raw deserialization fn for objects
            </summary>
        </member>
        <member name="F:ServiceStack.Text.JsConfig`1.ExcludePropertyNames">
            <summary>
            Exclude specific properties of this type from being serialized
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsConfig`1.TreatValueAsRefType">
            <summary>
            Opt-in flag to set some Value Types to be treated as a Ref Type
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsConfig`1.HasSerializeFn">
            <summary>
            Whether there is a fn (raw or otherwise)
            </summary>
        </member>
        <member name="F:ServiceStack.Text.PropertyConvention.Strict">
            <summary>
            The property names on target types must match property names in the JSON source
            </summary>
        </member>
        <member name="F:ServiceStack.Text.PropertyConvention.Lenient">
            <summary>
            The property names on target types may not match the property names in the JSON source
            </summary>
        </member>
        <member name="F:ServiceStack.Text.TimeSpanHandler.DurationFormat">
            <summary>
            Uses the xsd format like PT15H10M20S
            </summary>
        </member>
        <member name="F:ServiceStack.Text.TimeSpanHandler.StandardFormat">
            <summary>
            Uses the standard .net ToString method of the TimeSpan class
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonExtensions.Get``1(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Get JSON string value converted to T
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonExtensions.Get(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
            <summary>
            Get JSON string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonObject.GetUnescaped(System.String)">
            <summary>
            Get unescaped string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonObject.Child(System.String)">
            <summary>
            Get unescaped string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonObject.WriteValue(System.IO.TextWriter,System.Object)">
            <summary>
            Write JSON Array, Object, bool or number values as raw string
            </summary>
        </member>
        <member name="P:ServiceStack.Text.JsonObject.Item(System.String)">
            <summary>
            Get JSON string value
            </summary>
        </member>
        <member name="T:ServiceStack.Text.JsonSerializer">
            <summary>
            Creates an instance of a Type from a string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.JsonSerializer`1.DeserializeFromString(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.Json.JsonTypeSerializer.WriteRawString(System.IO.TextWriter,System.String)">
            <summary>
            Shortcut escape when we're sure value doesn't contain any escaped chars
            </summary>
            <param name="writer"></param>
            <param name="value"></param>
        </member>
        <member name="M:ServiceStack.Text.Json.JsonTypeSerializer.ConvertFromUtf32(System.Int32)">
            <summary>
            Given a character as utf32, returns the equivalent string provided that the character
            is legal json.
            </summary>
            <param name="utf32"></param>
            <returns></returns>
        </member>
        <member name="F:ServiceStack.Text.Json.JsonUtils.EscapedBackslash">
            <summary>
            Micro-optimization keep pre-built char arrays saving a .ToCharArray() + function call (see .net implementation of .Write(string))
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Json.JsonUtils.HasAnyEscapeChars(System.String)">
            <summary>
            Searches the string for one or more non-printable characters.
            </summary>
            <param name="value">The string to search.</param>
            <returns>True if there are any characters that require escaping. False if the value can be written verbatim.</returns>
            <remarks>
            Micro optimizations: since quote and backslash are the only printable characters requiring escaping, removed previous optimization
            (using flags instead of value.IndexOfAny(EscapeChars)) in favor of two equality operations saving both memory and CPU time.
            Also slightly reduced code size by re-arranging conditions.
            TODO: Possible Linq-only solution requires profiling: return value.Any(c => !c.IsPrintable() || c == QuoteChar || c == EscapeChar);
            </remarks>
        </member>
        <member name="T:ServiceStack.Text.Json.JsonWriter`1">
            <summary>
            Implement the serializer using a more static approach
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Text.Jsv.JsvWriter`1">
            <summary>
            Implement the serializer using a more static approach
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Licensing">
            <summary>
            Public Code API to register commercial license for ServiceStack.
            </summary>
        </member>
        <member name="T:ServiceStack.LicenseUtils">
            <summary>
            Internal Utilities to verify licensing
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Marc.Link`2">
            <summary>
            Pretty Thread-Safe cache class from:
            http://code.google.com/p/dapper-dot-net/source/browse/Dapper/SqlMapper.cs
            
            This is a micro-cache; suitable when the number of terms is controllable (a few hundred, for example),
            and strictly append-only; you cannot change existing values. All key matches are on **REFERENCE**
            equality. The type is fully thread-safe.
            </summary>
        </member>
        <member name="M:ServiceStack.PathUtils.MapProjectPath(System.String)">
            <summary>
            Maps the path of a file in the context of a VS project
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is two directories above the /bin/ directory,
            eg. in a unit test scenario  the assembly would be in /bin/Debug/.</remarks>
        </member>
        <member name="M:ServiceStack.PathUtils.MapAbsolutePath(System.String)">
            <summary>
            Maps the path of a file in a self-hosted scenario
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is copied to /bin/ folder with the assemblies</remarks>
        </member>
        <member name="M:ServiceStack.PathUtils.MapHostAbsolutePath(System.String)">
            <summary>
            Maps the path of a file in an Asp.Net hosted scenario
            </summary>
            <param name="relativePath">the relative path</param>
            <returns>the absolute path</returns>
            <remarks>Assumes static content is in the parent folder of the /bin/ directory</remarks>
        </member>
        <member name="T:ServiceStack.Text.FastMember.ObjectAccessor">
            <summary>
            Represents an individual object, allowing access to members by-name
            </summary>
        </member>
        <member name="M:ServiceStack.Text.FastMember.ObjectAccessor.Equals(System.Object)">
            <summary>
            Use the target types definition of equality
            </summary>
        </member>
        <member name="M:ServiceStack.Text.FastMember.ObjectAccessor.GetHashCode">
            <summary>
            Obtain the hash of the target object
            </summary>
        </member>
        <member name="M:ServiceStack.Text.FastMember.ObjectAccessor.ToString">
            <summary>
            Use the target's definition of a string representation
            </summary>
        </member>
        <member name="M:ServiceStack.Text.FastMember.ObjectAccessor.Create(System.Object)">
            <summary>
            Wraps an individual object, allowing by-name access to that instance
            </summary>
        </member>
        <member name="P:ServiceStack.Text.FastMember.ObjectAccessor.Item(System.String)">
            <summary>
            Get or Set the value of a named member for the underlying object
            </summary>
        </member>
        <member name="P:ServiceStack.Text.FastMember.ObjectAccessor.Target">
            <summary>
            The object represented by this instance
            </summary>
        </member>
        <member name="T:ServiceStack.Text.FastMember.TypeAccessor">
            <summary>
            Provides by-name member-access to objects of a given type
            </summary>
        </member>
        <member name="M:ServiceStack.Text.FastMember.TypeAccessor.CreateNew">
            <summary>
            Create a new instance of this type
            </summary>
        </member>
        <member name="M:ServiceStack.Text.FastMember.TypeAccessor.Create(System.Type)">
            <summary>
            Provides a type-specific accessor, allowing by-name access for all objects of that type
            </summary>
            <remarks>The accessor is cached internally; a pre-existing accessor may be returned</remarks>
        </member>
        <member name="P:ServiceStack.Text.FastMember.TypeAccessor.CreateNewSupported">
            <summary>
            Does this type support new instances via a parameterless constructor?
            </summary>
        </member>
        <member name="P:ServiceStack.Text.FastMember.TypeAccessor.Item(System.Object,System.String)">
            <summary>
            Get or set the value of a named member on the target instance
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Pools.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.Pools.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:ServiceStack.Text.Pools.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="T:ServiceStack.Text.Pools.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Pools.SharedPools">
            <summary>
            Shared object pool for roslyn
            
            Use this shared pool if only concern is reducing object allocations.
            if perf of an object pool itself is also a concern, use ObjectPool directly.
            
            For example, if you want to create a million of small objects within a second, 
            use the ObjectPool directly. it should have much less overhead than using this.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.ByteBufferSize">
            pooled memory : 4K * 512 = 4MB
        </member>
        <member name="M:ServiceStack.Text.Pools.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Pools.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Pools.SharedPools.StringIgnoreCaseDictionary``1">
            <summary>
            pool that uses string as key with StringComparer.OrdinalIgnoreCase as key comparer
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.StringIgnoreCaseHashSet">
            <summary>
            pool that uses string as element with StringComparer.OrdinalIgnoreCase as element comparer
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.StringHashSet">
            <summary>
            pool that uses string as element with StringComparer.Ordinal as element comparer
            </summary>
        </member>
        <member name="F:ServiceStack.Text.Pools.SharedPools.ByteArray">
            <summary>
            Used to reduce the # of temporary byte[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="T:ServiceStack.QueryStringWriter`1">
            <summary>
            Implement the serializer using a more static approach
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ServiceStack.Text.RecyclableMemoryStreamManager">
            <summary>
            Manages pools of RecyclableMemoryStream objects.
            </summary>
            <remarks>
            There are two pools managed in here. The small pool contains same-sized buffers that are handed to streams
            as they write more data.
            
            For scenarios that need to call GetBuffer(), the large pool contains buffers of various sizes, all
            multiples of LargeBufferMultiple (1 MB by default). They are split by size to avoid overly-wasteful buffer
            usage. There should be far fewer 8 MB buffers than 1 MB buffers, for example.
            </remarks>
        </member>
        <member name="F:ServiceStack.Text.RecyclableMemoryStreamManager.largePools">
            <summary>
            pools[0] = 1x largeBufferMultiple buffers
            pools[1] = 2x largeBufferMultiple buffers
            etc., up to maximumBufferSize
            </summary>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.#ctor">
            <summary>
            Initializes the memory manager with the default block/buffer specifications.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the memory manager with the given block requiredSize.
            </summary>
            <param name="blockSize">Size of each block that is pooled. Must be &gt; 0.</param>
            <param name="largeBufferMultiple">Each large buffer will be a multiple of this value.</param>
            <param name="maximumBufferSize">Buffers larger than this are not pooled</param>
            <exception cref="T:System.ArgumentOutOfRangeException">blockSize is not a positive number, or largeBufferMultiple is not a positive number, or maximumBufferSize is less than blockSize.</exception>
            <exception cref="T:System.ArgumentException">maximumBufferSize is not a multiple of largeBufferMultiple</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetBlock">
            <summary>
            Removes and returns a single block from the pool.
            </summary>
            <returns>A byte[] array</returns>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetLargeBuffer(System.Int32,System.String)">
            <summary>
            Returns a buffer of arbitrary size from the large buffer pool. This buffer
            will be at least the requiredSize and always be a multiple of largeBufferMultiple.
            </summary>
            <param name="requiredSize">The minimum length of the buffer</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <returns>A buffer of at least the required size.</returns>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.ReturnLargeBuffer(System.Byte[],System.String)">
            <summary>
            Returns the buffer to the large pool
            </summary>
            <param name="buffer">The buffer to return.</param>
            <param name="tag">The tag of the stream returning this buffer, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentException">buffer.Length is not a multiple of LargeBufferMultiple (it did not originate from this pool)</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.ReturnBlocks(System.Collections.Generic.ICollection{System.Byte[]},System.String)">
            <summary>
            Returns the blocks to the pool
            </summary>
            <param name="blocks">Collection of blocks to return to the pool</param>
            <param name="tag">The tag of the stream returning these blocks, for logging if necessary.</param>
            <exception cref="T:System.ArgumentNullException">blocks is null</exception>
            <exception cref="T:System.ArgumentException">blocks contains buffers that are the wrong size (or null) for this memory manager</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetStream">
            <summary>
            Retrieve a new MemoryStream object with no tag and a default initial capacity.
            </summary>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetStream(System.String)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and a default initial capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity.
            </summary>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetStream(System.String,System.Int32,System.Boolean)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and at least the given capacity, possibly using
            a single continugous underlying buffer.
            </summary>
            <remarks>Retrieving a MemoryStream which provides a single contiguous buffer can be useful in situations
            where the initial size is known and it is desirable to avoid copying data between the smaller underlying
            buffers to a single large one. This is most helpful when you know that you will always call GetBuffer
            on the underlying stream.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="requiredSize">The minimum desired capacity for the stream.</param>
            <param name="asContiguousBuffer">Whether to attempt to use a single contiguous buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStreamManager.GetStream(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Retrieve a new MemoryStream object with the given tag and with contents copied from the provided
            buffer. The provided buffer is not wrapped or used after construction.
            </summary>
            <remarks>The new stream's position is set to the beginning of the stream when returned.</remarks>
            <param name="tag">A tag which can be used to track the source of the stream.</param>
            <param name="buffer">The byte buffer to copy data from.</param>
            <param name="offset">The offset from the start of the buffer to copy from.</param>
            <param name="count">The number of bytes to copy from the buffer.</param>
            <returns>A MemoryStream.</returns>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.BlockSize">
            <summary>
            The size of each block. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.LargeBufferMultiple">
            <summary>
            All buffers are multiples of this number. It must be set at creation and cannot be changed.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.MaximumBufferSize">
            <summary>
            Gets or sets the maximum buffer size.
            </summary>
            <remarks>Any buffer that is returned to the pool that is larger than this will be
            discarded and garbage collected.</remarks>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.SmallPoolFreeSize">
            <summary>
            Number of bytes in small pool not currently in use
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.SmallPoolInUseSize">
            <summary>
            Number of bytes currently in use by stream from the small pool
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.LargePoolFreeSize">
            <summary>
            Number of bytes in large pool not currently in use
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.LargePoolInUseSize">
            <summary>
            Number of bytes currently in use by streams from the large pool
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.SmallBlocksFree">
            <summary>
            How many blocks are in the small pool
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.LargeBuffersFree">
            <summary>
            How many buffers are in the large pool
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.MaximumFreeSmallPoolBytes">
            <summary>
            How many bytes of small free blocks to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.MaximumFreeLargePoolBytes">
            <summary>
            How many bytes of large free buffers to allow before we start dropping
            those returned to us.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.MaximumStreamCapacity">
            <summary>
            Maximum stream capacity in bytes. Attempts to set a larger capacity will
            result in an exception.
            </summary>
            <remarks>A value of 0 indicates no limit.</remarks>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.GenerateCallStacks">
            <summary>
            Whether to save callstacks for stream allocations. This can help in debugging.
            It should NEVER be turned on generally in production.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStreamManager.AggressiveBufferReturn">
            <summary>
            Whether dirty buffers can be immediately returned to the buffer pool. E.g. when GetBuffer() is called on
            a stream and creates a single large buffer, if this setting is enabled, the other blocks will be returned
            to the buffer pool immediately.
            Note when enabling this setting that the user is responsible for ensuring that any buffer previously
            retrieved from a stream which is subsequently modified is not used after modification (as it may no longer
            be valid).
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.BlockCreated">
            <summary>
            Triggered when a new block is created.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.BlockDiscarded">
            <summary>
            Triggered when a new block is created.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.LargeBufferCreated">
            <summary>
            Triggered when a new large buffer is created.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.StreamCreated">
            <summary>
            Triggered when a new stream is created.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.StreamDisposed">
            <summary>
            Triggered when a stream is disposed.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.StreamFinalized">
            <summary>
            Triggered when a stream is finalized.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.StreamLength">
            <summary>
            Triggered when a stream is finalized.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.StreamConvertedToArray">
            <summary>
            Triggered when a user converts a stream to array.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.LargeBufferDiscarded">
            <summary>
            Triggered when a large buffer is discarded, along with the reason for the discard.
            </summary>
        </member>
        <member name="E:ServiceStack.Text.RecyclableMemoryStreamManager.UsageReport">
            <summary>
            Periodically triggered to report usage statistics.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.RecyclableMemoryStreamManager.EventHandler">
            <summary>
            Generic delegate for handling events without any arguments.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.RecyclableMemoryStreamManager.LargeBufferDiscardedEventHandler">
            <summary>
            Delegate for handling large buffer discard reports.
            </summary>
            <param name="reason">Reason the buffer was discarded.</param>
        </member>
        <member name="T:ServiceStack.Text.RecyclableMemoryStreamManager.StreamLengthReportHandler">
            <summary>
            Delegate for handling reports of stream size when streams are allocated
            </summary>
            <param name="bytes">Bytes allocated.</param>
        </member>
        <member name="T:ServiceStack.Text.RecyclableMemoryStreamManager.UsageReportEventHandler">
            <summary>
            Delegate for handling periodic reporting of memory use statistics.
            </summary>
            <param name="smallPoolInUseBytes">Bytes currently in use in the small pool.</param>
            <param name="smallPoolFreeBytes">Bytes currently free in the small pool.</param>
            <param name="largePoolInUseBytes">Bytes currently in use in the large pool.</param>
            <param name="largePoolFreeBytes">Bytes currently free in the large pool.</param>
        </member>
        <member name="T:ServiceStack.Text.RecyclableMemoryStream">
            <summary>
            MemoryStream implementation that deals with pooling and managing memory streams which use potentially large
            buffers.
            </summary>
            <remarks>
            This class works in tandem with the RecylableMemoryStreamManager to supply MemoryStream
            objects to callers, while avoiding these specific problems:
            1. LOH allocations - since all large buffers are pooled, they will never incur a Gen2 GC
            2. Memory waste - A standard memory stream doubles its size when it runs out of room. This
            leads to continual memory growth as each stream approaches the maximum allowed size.
            3. Memory copying - Each time a MemoryStream grows, all the bytes are copied into new buffers.
            This implementation only copies the bytes when GetBuffer is called.
            4. Memory fragmentation - By using homogeneous buffer sizes, it ensures that blocks of memory
            can be easily reused.
            
            The stream is implemented on top of a series of uniformly-sized blocks. As the stream's length grows,
            additional blocks are retrieved from the memory manager. It is these blocks that are pooled, not the stream
            object itself.
            
            The biggest wrinkle in this implementation is when GetBuffer() is called. This requires a single 
            contiguous buffer. If only a single block is in use, then that block is returned. If multiple blocks 
            are in use, we retrieve a larger buffer from the memory manager. These large buffers are also pooled, 
            split by size--they are multiples of a chunk size (1 MB by default).
            
            Once a large buffer is assigned to the stream the blocks are NEVER again used for this stream. All operations take place on the 
            large buffer. The large buffer can be replaced by a larger buffer from the pool as needed. All blocks and large buffers 
            are maintained in the stream until the stream is disposed (unless AggressiveBufferReturn is enabled in the stream manager).
            
            </remarks>
        </member>
        <member name="F:ServiceStack.Text.RecyclableMemoryStream.blocks">
            <summary>
            All of these blocks must be the same size
            </summary>
        </member>
        <member name="F:ServiceStack.Text.RecyclableMemoryStream.largeBuffer">
            <summary>
            This is only set by GetBuffer() if the necessary buffer is larger than a single block size, or on
            construction if the caller immediately requests a single large buffer.
            </summary>
            <remarks>If this field is non-null, it contains the concatenation of the bytes found in the individual
            blocks. Once it is created, this (or a larger) largeBuffer will be used for the life of the stream.
            </remarks>
        </member>
        <member name="F:ServiceStack.Text.RecyclableMemoryStream.dirtyBuffers">
            <summary>
            This list is used to store buffers once they're replaced by something larger.
            This is for the cases where you have users of this class that may hold onto the buffers longer
            than they should and you want to prevent race conditions which could corrupt the data.
            </summary>
        </member>
        <member name="F:ServiceStack.Text.RecyclableMemoryStream.byteBuffer">
            <summary>
            This buffer exists so that WriteByte can forward all of its calls to Write
            without creating a new byte[] buffer on every call.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.#ctor(ServiceStack.Text.RecyclableMemoryStreamManager)">
            <summary>
            Allocate a new RecyclableMemoryStream object.
            </summary>
            <param name="memoryManager">The memory manager</param>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.#ctor(ServiceStack.Text.RecyclableMemoryStreamManager,System.String)">
            <summary>
            Allocate a new RecyclableMemoryStream object
            </summary>
            <param name="memoryManager">The memory manager</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes</param>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.#ctor(ServiceStack.Text.RecyclableMemoryStreamManager,System.String,System.Int32)">
            <summary>
            Allocate a new RecyclableMemoryStream object
            </summary>
            <param name="memoryManager">The memory manager</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes</param>
            <param name="requestedSize">The initial requested size to prevent future allocations</param>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.#ctor(ServiceStack.Text.RecyclableMemoryStreamManager,System.String,System.Int32,System.Byte[])">
            <summary>
            Allocate a new RecyclableMemoryStream object
            </summary>
            <param name="memoryManager">The memory manager</param>
            <param name="tag">A string identifying this stream for logging and debugging purposes</param>
            <param name="requestedSize">The initial requested size to prevent future allocations</param>
            <param name="initialLargeBuffer">An initial buffer to use. This buffer will be owned by the stream and returned to the memory manager upon Dispose.</param>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.Dispose(System.Boolean)">
            <summary>
            Returns the memory used by this stream back to the pool.
            </summary>
            <param name="disposing">Whether we're disposing (true), or being called by the finalizer (false)</param>
            <remarks>This method is not thread safe and it may not be called more than once.</remarks>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.Close">
            <summary>
            Equivalent to Dispose
            </summary>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.GetBuffer">
            <summary>
            Returns a single buffer containing the contents of the stream.
            The buffer may be longer than the stream length.
            </summary>
            <returns>A byte[] buffer</returns>
            <remarks>IMPORTANT: Doing a Write() after calling GetBuffer() invalidates the buffer. The old buffer is held onto
            until Dispose is called, but the next time GetBuffer() is called, a new buffer from the pool will be required.</remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.ToArray">
            <summary>
            Returns a new array with a copy of the buffer's contents. You should almost certainly be using GetBuffer combined with the Length to 
            access the bytes in this stream. Calling ToArray will destroy the benefits of pooled buffers, but it is included
            for the sake of completeness.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads from the current position into the provided buffer
            </summary>
            <param name="buffer">Destination buffer</param>
            <param name="offset">Offset into buffer at which to start placing the read bytes.</param>
            <param name="count">Number of bytes to read.</param>
            <returns>The number of bytes read</returns>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is less than 0</exception>
            <exception cref="T:System.ArgumentException">offset subtracted from the buffer length is less than count</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes the buffer to the stream
            </summary>
            <param name="buffer">Source buffer</param>
            <param name="offset">Start position</param>
            <param name="count">Number of bytes to write</param>
            <exception cref="T:System.ArgumentNullException">buffer is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset or count is negative</exception>
            <exception cref="T:System.ArgumentException">buffer.Length - offset is not less than count</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.ToString">
            <summary>
            Returns a useful string for debugging. This should not normally be called in actual production code.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the current position in the stream.
            </summary>
            <param name="value">byte value to write</param>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.ReadByte">
            <summary>
            Reads a single byte from the current position in the stream.
            </summary>
            <returns>The byte at the current position, or -1 if the position is at the end of the stream.</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.SetLength(System.Int64)">
            <summary>
            Sets the length of the stream
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">value is negative or larger than MaxStreamLength</exception>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position to the offset from the seek location
            </summary>
            <param name="offset">How many bytes to move</param>
            <param name="loc">From where</param>
            <returns>The new position</returns>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">offset is larger than MaxStreamLength</exception>
            <exception cref="T:System.ArgumentException">Invalid seek origin</exception>
            <exception cref="T:System.IO.IOException">Attempt to set negative position</exception>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.WriteTo(System.IO.Stream)">
            <summary>
            Synchronously writes this stream's bytes to the parameter stream.
            </summary>
            <param name="stream">Destination stream</param>
            <remarks>Important: This does a synchronous write, which may not be desired in some situations</remarks>
        </member>
        <member name="M:ServiceStack.Text.RecyclableMemoryStream.ReleaseLargeBuffer">
            <summary>
            Release the large buffer (either stores it for eventual release or returns it immediately).
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.Id">
            <summary>
            Unique identifier for this stream across it's entire lifetime
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.Tag">
            <summary>
            A temporary identifier for the current usage of this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.MemoryManager">
            <summary>
            Gets the memory manager being used by this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.AllocationStack">
            <summary>
            Callstack of the constructor. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.DisposeStack">
            <summary>
            Callstack of the Dispose call. It is only set if MemoryManager.GenerateCallStacks is true,
            which should only be in debugging situations.
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.Capacity">
            <summary>
            Gets or sets the capacity
            </summary>
            <remarks>Capacity is always in multiples of the memory manager's block size, unless
            the large buffer is in use.  Capacity never decreases during a stream's lifetime. 
            Explicitly setting the capacity to a lower value than the current value will have no effect. 
            This is because the buffers are all pooled by chunks and there's little reason to 
            allow stream truncation.
            </remarks>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.Length">
            <summary>
            Gets the number of bytes written to this stream.
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.Position">
            <summary>
            Gets the current position in the stream
            </summary>
            <exception cref="T:System.ObjectDisposedException">Object has been disposed</exception>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.CanRead">
            <summary>
            Whether the stream can currently read
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.CanSeek">
            <summary>
            Whether the stream can currently seek
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.CanTimeout">
            <summary>
            Always false
            </summary>
        </member>
        <member name="P:ServiceStack.Text.RecyclableMemoryStream.CanWrite">
            <summary>
            Whether the stream can currently write
            </summary>
        </member>
        <member name="M:ServiceStack.ReflectionExtensions.New``1(System.Type)">
            <summary>
            Creates a new instance of type. 
            First looks at JsConfig.ModelFactory before falling back to CreateInstance
            </summary>
        </member>
        <member name="M:ServiceStack.ReflectionExtensions.New(System.Type)">
            <summary>
            Creates a new instance of type. 
            First looks at JsConfig.ModelFactory before falling back to CreateInstance
            </summary>
        </member>
        <member name="M:ServiceStack.ReflectionExtensions.CreateInstance(System.Type)">
            <summary>
            Creates a new instance from the default constructor of type
            </summary>
        </member>
        <member name="M:ServiceStack.PlatformExtensions.AddAttributes(System.Reflection.PropertyInfo,System.Attribute[])">
            <summary>
            Add a Property attribute at runtime. 
            <para>Not threadsafe, should only add attributes on Startup.</para>
            </summary>
        </member>
        <member name="M:ServiceStack.PlatformExtensions.ReplaceAttribute(System.Reflection.PropertyInfo,System.Attribute)">
            <summary>
            Add a Property attribute at runtime. 
            <para>Not threadsafe, should only add attributes on Startup.</para>
            </summary>
        </member>
        <member name="F:ServiceStack.StreamExtensions.DefaultBufferSize">
            <summary>
            @jonskeet: Collection of utility methods which operate on streams.
            r285, February 26th 2009: http://www.yoda.arachsys.com/csharp/miscutil/
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadFully(System.IO.Stream)">
            <summary>
            Reads the given stream up to the end, returning the data as a byte
            array.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadFully(System.IO.Stream,System.Int32)">
            <summary>
            Reads the given stream up to the end, returning the data as a byte
            array, using the given buffer size.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadFully(System.IO.Stream,System.Byte[])">
            <summary>
            Reads the given stream up to the end, returning the data as a byte
            array, using the given buffer for transferring data. Note that the
            current contents of the buffer is ignored, so the buffer needn't
            be cleared beforehand.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies all the data from one stream into another.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32)">
            <summary>
            Copies all the data from one stream into another, using a buffer
            of the given size.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.CopyTo(System.IO.Stream,System.IO.Stream,System.Byte[])">
            <summary>
            Copies all the data from one stream into another, using the given 
            buffer for transferring data. Note that the current contents of 
            the buffer is ignored, so the buffer needn't be cleared beforehand.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Int32)">
            <summary>
            Reads exactly the given number of bytes from the specified stream.
            If the end of the stream is reached before the specified amount
            of data is read, an exception is thrown.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Byte[])">
            <summary>
            Reads into a buffer, filling it completely.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Byte[],System.Int32)">
            <summary>
            Reads exactly the given number of bytes from the specified stream,
            into the given buffer, starting at position 0 of the array.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactly(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads exactly the given number of bytes from the specified stream,
            into the given buffer, starting at position 0 of the array.
            </summary>
        </member>
        <member name="M:ServiceStack.StreamExtensions.ReadExactlyFast(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Same as ReadExactly, but without the argument checks.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringBuilderCache">
            <summary>
            Reusable StringBuilder ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringBuilderCacheAlt">
            <summary>
            Alternative Reusable StringBuilder ThreadStatic Cache
            </summary>
        </member>
        <member name="M:ServiceStack.StringExtensions.BaseConvert(System.String,System.Int32,System.Int32)">
            <summary>
            Converts from base: 0 - 62
            </summary>
            <param name="source">The source.</param>
            <param name="from">From.</param>
            <param name="to">To.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.StringExtensions.FastToUtf8Bytes(System.String)">
            <summary>
            Skip the encoding process for 'safe strings' 
            </summary>
            <param name="strVal"></param>
            <returns></returns>
        </member>
        <member name="T:ServiceStack.Text.StringWriterCache">
            <summary>
            Reusable StringWriter ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.StringWriterCacheAlt">
            <summary>
            Alternative Reusable StringWriter ThreadStatic Cache
            </summary>
        </member>
        <member name="T:ServiceStack.Text.Support.DoubleConverter">
            <summary>
            A class to allow the conversion of doubles to string representations of
            their exact decimal values. The implementation aims for readability over
            efficiency.
            
            Courtesy of @JonSkeet
            http://www.yoda.arachsys.com/csharp/DoubleConverter.cs
            </summary>
        </member>
        <!-- 对于成员“M:ServiceStack.Text.Support.DoubleConverter.ToExactString(System.Double)”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“T:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal”忽略有格式错误的 XML 注释 -->
        <!-- 对于成员“F:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.digits”忽略有格式错误的 XML 注释 -->
        <member name="F:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.decimalPoint">
            <summary> 
            How many digits are *after* the decimal point
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.#ctor(System.Int64)">
            <summary> 
            Constructs an arbitrary decimal expansion from the given long.
            The long must not be negative.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.MultiplyBy(System.Int32)">
            <summary>
            Multiplies the current expansion by the given amount, which should
            only be 2 or 5.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.Shift(System.Int32)">
            <summary>
            Shifts the decimal point; a negative value makes
            the decimal expansion bigger (as fewer digits come after the
            decimal place) and a positive value makes the decimal
            expansion smaller.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.Normalize">
            <summary>
            Removes leading/trailing zeroes from the expansion.
            </summary>
        </member>
        <member name="M:ServiceStack.Text.Support.DoubleConverter.ArbitraryDecimal.ToString">
            <summary>
            Converts the value to a proper decimal string representation.
            </summary>
        </member>
        <member name="T:ServiceStack.Text.TypeSerializer">
            <summary>
            Creates an instance of a Type from a string value
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.CanCreateFromString(System.Type)">
            <summary>
            Determines whether the specified type is convertible from string.
            </summary>
            <param name="type">The type.</param>
            <returns>
            	<c>true</c> if the specified type is convertible from string; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.DeserializeFromString``1(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.DeserializeFromString(System.String,System.Type)">
            <summary>
            Parses the specified type.
            </summary>
            <param name="type">The type.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.ToStringDictionary``1(``0)">
            <summary>
            Useful extension method to get the Dictionary[string,string] representation of any POCO type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.Dump``1(``0)">
            <summary>
            Recursively prints the contents of any POCO object in a human-friendly, readable format
            </summary>
            <returns></returns>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.PrintDump``1(``0)">
            <summary>
            Print Dump to Console.WriteLine
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer.Print(System.String,System.Object[])">
            <summary>
            Print string.Format to Console.WriteLine
            </summary>
        </member>
        <member name="M:ServiceStack.Text.TypeSerializer`1.DeserializeFromString(System.String)">
            <summary>
            Parses the specified value.
            </summary>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
    </members>
</doc>
